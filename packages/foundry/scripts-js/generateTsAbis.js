import {
  readdirSync,
  statSync,
  readFileSync,
  existsSync,
  mkdirSync,
  writeFileSync,
} from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import { format } from "prettier";

const __dirname = dirname(fileURLToPath(import.meta.url));

const generatedContractComment = `
/**
 * This file is autogenerated by Scaffold-ETH.
 * You should not edit it manually or your changes might be overwritten.
 */`;

function getDirectories(path) {
  if (!existsSync(path)) return [];
  return readdirSync(path).filter((file) =>
    statSync(join(path, file)).isDirectory(),
  );
}

function getFiles(path) {
  return readdirSync(path).filter((file) =>
    statSync(join(path, file)).isFile(),
  );
}

function parseTransactionRun(filePath) {
  try {
    const content = readFileSync(filePath, "utf8");
    const broadcastData = JSON.parse(content);

    // Extract minimum block number from receipts
    let minBlockNumber = null;
    if (broadcastData.receipts) {
      for (const receipt of broadcastData.receipts) {
        if (receipt.blockNumber) {
          const blockNum = parseInt(receipt.blockNumber, 16);
          if (minBlockNumber === null || blockNum < minBlockNumber) {
            minBlockNumber = blockNum;
          }
        }
      }
    }

    return {
      transactions: broadcastData.transactions || [],
      minBlockNumber,
    };
  } catch (error) {
    return { transactions: [], minBlockNumber: null };
  }
}

function getDeploymentHistory(broadcastPath) {
  const files = getFiles(broadcastPath);
  const deploymentHistory = new Map();
  let chainMinBlock = null;

  const runFiles = files
    .filter(
      (file) =>
        file.startsWith("run-") &&
        file.endsWith(".json") &&
        !file.includes("run-latest"),
    )
    .sort((a, b) => {
      const runA = parseInt(a.match(/run-(\d+)/)?.[1] || "0");
      const runB = parseInt(b.match(/run-(\d+)/)?.[1] || "0");
      return runA - runB;
    });

  for (const file of runFiles) {
    const { transactions, minBlockNumber } = parseTransactionRun(
      join(broadcastPath, file),
    );

    // Track the minimum block number across all runs
    if (minBlockNumber !== null) {
      if (chainMinBlock === null || minBlockNumber < chainMinBlock) {
        chainMinBlock = minBlockNumber;
      }
    }

    // First pass: collect all deployments and track implementation addresses
    const implementationAddresses = new Map(); // address -> contractName
    const proxyDeployments = []; // proxy deployments to process after

    for (const tx of transactions) {
      if (tx.transactionType === "CREATE" || tx.transactionType === "CREATE2") {
        const normalizedAddress = tx.contractAddress.toLowerCase();
        if (tx.contractName === "ERC1967Proxy") {
          proxyDeployments.push(tx);
        } else {
          implementationAddresses.set(normalizedAddress, tx.contractName);
          deploymentHistory.set(normalizedAddress, {
            contractName: tx.contractName,
            address: tx.contractAddress,
            deploymentFile: file,
            transaction: tx,
          });
        }
      }
    }

    // Second pass: handle ERC1967Proxy deployments
    for (const tx of proxyDeployments) {
      // First argument to ERC1967Proxy is the implementation address
      const implAddress = tx.arguments?.[0]?.toLowerCase();
      const implContractName = implAddress
        ? implementationAddresses.get(implAddress)
        : null;

      if (implContractName) {
        // This proxy wraps an implementation - use proxy address but implementation name
        // Remove the implementation entry and replace with proxy entry using impl name
        if (implAddress && deploymentHistory.has(implAddress)) {
          deploymentHistory.delete(implAddress);
        }
        deploymentHistory.set(tx.contractAddress.toLowerCase(), {
          contractName: implContractName, // Use implementation's name
          address: tx.contractAddress, // But proxy's address
          deploymentFile: file,
          transaction: tx,
          isProxy: true,
          implementationName: implContractName,
        });
      } else {
        // Regular ERC1967Proxy without detected implementation
        deploymentHistory.set(tx.contractAddress.toLowerCase(), {
          contractName: tx.contractName,
          address: tx.contractAddress,
          deploymentFile: file,
          transaction: tx,
        });
      }
    }
  }

  return {
    deployments: Array.from(deploymentHistory.values()),
    minBlockNumber: chainMinBlock,
  };
}

function getArtifactOfContract(contractName) {
  const standard_path = join(__dirname, "..", `out/${contractName}.sol`);
  if (existsSync(standard_path)) {
    const artifactPath = `${standard_path}/${contractName}.json`;
    if (existsSync(artifactPath)) {
      return JSON.parse(readFileSync(artifactPath));
    }
  }

  const outDir = join(__dirname, "..", "out");
  if (existsSync(outDir)) {
    const solDirs = getDirectories(outDir);
    for (const solDir of solDirs) {
      const artifactPath = join(outDir, solDir, `${contractName}.json`);
      if (existsSync(artifactPath)) {
        return JSON.parse(readFileSync(artifactPath));
      }
    }
  }
  return null;
}

function minParam(p) {
  const m = { name: p.name || "", type: p.type };
  if (p.components) m.components = p.components.map(minParam);
  if (p.indexed) m.indexed = true;
  return m;
}

function minimalAbi(entry) {
  const m = { type: entry.type };

  if (
    entry.name &&
    !["constructor", "fallback", "receive"].includes(entry.type)
  ) {
    m.name = entry.name;
  }

  if (entry.inputs?.length > 0) {
    m.inputs = entry.inputs.map(minParam);
  }

  if (entry.outputs?.length > 0) {
    m.outputs = entry.outputs.map((o) => {
      const out = { type: o.type };
      if (o.name) out.name = o.name;
      if (o.components) out.components = o.components.map(minParam);
      return out;
    });
  }

  if (entry.type === "function" && entry.stateMutability) {
    m.stateMutability = entry.stateMutability;
  }

  if (entry.type === "constructor" && entry.stateMutability === "payable") {
    m.stateMutability = "payable";
  }

  if (entry.anonymous) m.anonymous = true;

  return m;
}

function filterAbi(abi) {
  const seen = new Set();
  const ozErrors = [
    "ERC20InsufficientBalance",
    "ERC20InvalidSender",
    "ERC20InvalidReceiver",
    "ERC20InsufficientAllowance",
    "ERC20InvalidApprover",
    "ERC20InvalidSpender",
    "OwnableUnauthorizedAccount",
    "OwnableInvalidOwner",
  ];
  const skipEvents = ["OwnershipTransferred"];
  const skipFuncs = [
    "supportsInterface",
    "_msgSender",
    "_msgData",
    "_contextSuffixLength",
  ];

  return abi.filter((e) => {
    if (["constructor", "fallback", "receive"].includes(e.type)) return true;

    if (e.type === "event") {
      if (["Transfer", "Approval"].includes(e.name)) return true;
      if (skipEvents.includes(e.name)) return false;
      return true;
    }

    if (e.type === "error") {
      if (ozErrors.includes(e.name)) return false;
      return true;
    }

    if (e.type === "function") {
      const sig = `${e.name}(${(e.inputs || []).map((i) => i.type).join(",")})`;
      if (seen.has(sig)) return false;
      seen.add(sig);
      if (skipFuncs.includes(e.name)) return false;
      return true;
    }

    return true;
  });
}

function getInheritedFromContracts(artifact) {
  let inheritedFromContracts = [];
  if (artifact?.ast) {
    for (const astNode of artifact.ast.nodes) {
      if (
        astNode.nodeType == "ContractDefinition" &&
        astNode.baseContracts.length > 0
      ) {
        inheritedFromContracts = astNode.baseContracts.map(
          ({ baseName }) => baseName.name,
        );
      }
    }
  }
  return inheritedFromContracts;
}

function getInheritedFunctions(mainArtifact) {
  const inheritedFromContracts = getInheritedFromContracts(mainArtifact);
  const inheritedFunctions = {};
  for (const inheritanceContractName of inheritedFromContracts) {
    const artifact = getArtifactOfContract(inheritanceContractName);
    if (artifact) {
      const {
        abi,
        ast: { absolutePath },
      } = artifact;
      for (const abiEntry of abi) {
        if (abiEntry.type == "function") {
          inheritedFunctions[abiEntry.name] = absolutePath;
        }
      }
    }
  }
  return inheritedFunctions;
}

function processAllDeployments(broadcastPath) {
  const scriptFolders = getDirectories(broadcastPath);
  const allDeployments = new Map();
  const chainMinBlocks = new Map(); // Track min block per chain

  scriptFolders.forEach((scriptFolder) => {
    const scriptPath = join(broadcastPath, scriptFolder);
    const chainFolders = getDirectories(scriptPath);

    chainFolders.forEach((chainId) => {
      const chainPath = join(scriptPath, chainId);
      const { deployments, minBlockNumber } = getDeploymentHistory(chainPath);

      // Track minimum block number per chain
      if (minBlockNumber !== null) {
        const currentMin = chainMinBlocks.get(chainId);
        if (currentMin === undefined || minBlockNumber < currentMin) {
          chainMinBlocks.set(chainId, minBlockNumber);
        }
      }

      deployments.forEach((deployment) => {
        const timestamp = parseInt(
          deployment.deploymentFile.match(/run-(\d+)/)?.[1] || "0",
        );
        const key = `${chainId}-${deployment.contractName}`;

        if (
          !allDeployments.has(key) ||
          timestamp > allDeployments.get(key).timestamp
        ) {
          allDeployments.set(key, {
            ...deployment,
            timestamp,
            chainId,
            deploymentScript: scriptFolder,
          });
        }
      });
    });
  });

  const allContracts = {};

  allDeployments.forEach((deployment) => {
    const { chainId, contractName } = deployment;
    const artifact = getArtifactOfContract(contractName);

    if (artifact) {
      if (!allContracts[chainId]) allContracts[chainId] = {};

      const filtered = filterAbi(artifact.abi);
      const minimal = filtered.map(minimalAbi);

      allContracts[chainId][contractName] = {
        address: deployment.address,
        abi: minimal,
        inheritedFunctions: getInheritedFunctions(artifact),
      };
    }
  });

  return {
    contracts: allContracts,
    chainMinBlocks: Object.fromEntries(chainMinBlocks),
  };
}

// Chain ID to name mapping
const CHAIN_NAMES = {
  1: "mainnet",
  8453: "base",
  31337: "foundry",
  11155111: "sepolia",
  84532: "baseSepolia",
  1301: "unichain",
};

function main() {
  const current_path_to_broadcast = join(__dirname, "..", "broadcast");
  const current_path_to_deployments = join(__dirname, "..", "deployments");

  const Deploymentchains = getFiles(current_path_to_deployments);
  const deployments = {};

  Deploymentchains.forEach((chain) => {
    if (!chain.endsWith(".json")) return;
    chain = chain.slice(0, -5);
    var deploymentObject = JSON.parse(
      readFileSync(`${current_path_to_deployments}/${chain}.json`),
    );
    deployments[chain] = deploymentObject;
  });

  const { contracts: allGeneratedContracts, chainMinBlocks } =
    processAllDeployments(current_path_to_broadcast);

  Object.entries(allGeneratedContracts).forEach(([chainId, contracts]) => {
    Object.entries(contracts).forEach(([contractName, contractData]) => {
      const deployedName = deployments[chainId]?.[contractData.address];
      if (deployedName) {
        allGeneratedContracts[chainId][deployedName] = contractData;
        delete allGeneratedContracts[chainId][contractName];
      }
    });
  });

  const NEXTJS_TARGET_DIR = "../opswap/contracts/";
  const CHAINS_DIR = join(NEXTJS_TARGET_DIR, "chains");

  if (!existsSync(NEXTJS_TARGET_DIR)) {
    mkdirSync(NEXTJS_TARGET_DIR, { recursive: true });
  }
  if (!existsSync(CHAINS_DIR)) {
    mkdirSync(CHAINS_DIR, { recursive: true });
  }

  const chainIds = Object.keys(allGeneratedContracts);
  let totalContracts = 0;
  let totalLines = 0;

  // Write individual chain files
  const chainFilePromises = chainIds.map((chainId) => {
    const chainConfig = allGeneratedContracts[chainId];
    const chainName = CHAIN_NAMES[chainId] || `chain${chainId}`;
    const contractCount = Object.keys(chainConfig).length;
    totalContracts += contractCount;

    // Get deployment block for this chain (default to 0 if not found)
    const deploymentBlock = chainMinBlocks[chainId] || 0;

    // Add chainId and deploymentBlock at the top of the config object
    const chainConfigWithId = {
      chainId: parseInt(chainId),
      deploymentBlock,
      ...chainConfig,
    };

    const fileContent = `
      ${generatedContractComment}
      const ${chainName}Contracts = ${JSON.stringify(chainConfigWithId, null, 2)} as const;

      export default ${chainName}Contracts;
    `;

    return format(fileContent, { parser: "typescript" }).then((result) => {
      const filename = `${chainName}.ts`;
      writeFileSync(join(CHAINS_DIR, filename), result);
      const lines = result.split("\n").length;
      totalLines += lines;
      return { chainId, chainName, filename, lines, contractCount };
    });
  });

  // Write index file that re-exports all chains
  Promise.all(chainFilePromises).then((chainFiles) => {
    const indexContent = `
      ${generatedContractComment}
      import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract";

      ${chainFiles
        .map(
          ({ chainName }) =>
            `import ${chainName}Contracts from "./chains/${chainName}";`,
        )
        .join("\n")}

      const deployedContracts = {
        ${chainFiles
          .map(
            ({ chainId, chainName }) =>
              `${parseInt(chainId).toFixed(0)}: ${chainName}Contracts`,
          )
          .join(",\n  ")}
      } as const;

      export default deployedContracts satisfies GenericContractsDeclaration;
    `;

    return format(indexContent, { parser: "typescript" }).then((result) => {
      writeFileSync(join(NEXTJS_TARGET_DIR, "deployedContracts.ts"), result);

      const indexLines = result.split("\n").length;
      const originalLines = 10962;
      const reduction = (
        ((originalLines - totalLines) / originalLines) *
        100
      ).toFixed(1);

      console.log(`\nâœ¨ SPLIT BY CHAIN - Individual files per chain!`);
      console.log(`\nðŸ“ Generated files:`);
      chainFiles.forEach(
        ({ chainId, chainName, filename, lines, contractCount }) => {
          console.log(
            `   ${filename.padEnd(20)} ${lines.toString().padStart(4)} lines, ${contractCount} contracts (Chain ${chainId})`,
          );
        },
      );
      console.log(
        `   ${"deployedContracts.ts".padEnd(20)} ${indexLines.toString().padStart(4)} lines (index)`,
      );

      console.log(`\nðŸ“Š Summary:`);
      console.log(`   Total contracts: ${totalContracts}`);
      console.log(
        `   Total lines: ${totalLines} (${reduction}% reduction from ${originalLines})`,
      );
      console.log(
        `   Average lines/chain: ${Math.round(totalLines / chainFiles.length)}`,
      );

      console.log(`\nðŸ’¾ Saved to: ${NEXTJS_TARGET_DIR}`);
      console.log(`   â”œâ”€â”€ deployedContracts.ts (index file)`);
      console.log(`   â””â”€â”€ chains/`);
      chainFiles.forEach(({ filename }) => {
        console.log(`       â”œâ”€â”€ ${filename}`);
      });

      console.log(`\nðŸŽ¯ Benefits:`);
      console.log(`   âœ… Smaller per-chain files (easier to review)`);
      console.log(`   âœ… Better tree-shaking (unused chains can be dropped)`);
      console.log(`   âœ… Faster TypeScript compilation`);
      console.log(`   âœ… Can dynamically import only chains you need\n`);
    });
  });
}

try {
  main();
} catch (error) {
  console.error("Error:", error);
  process.exitCode = 1;
}
